#pragma config(Sensor, S1,     ,               sensorEV3_Color)
#pragma config(Sensor, S2,     rightSensor,    sensorEV3_Color)
#pragma config(Sensor, S3,     leftSensor,     sensorEV3_Color)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-colour-v2.h"
#include "WRO_Lib.h"
float t; //excess's color
float ind1,ind2,ind3,ind4,ind5,ind6,blue,green,yellow,para; //variables for function info
void otvoz(short dom, short col)
{
	v=25; k1=0.2; k2=1;
	LineRed();
	stopmotor();
	if(dom==3)
	{
		if(ind5==col&&ind6==col)
		{
			para=para+2;
			hapuga('d');
			move_enc(200, v, 'b');
			hapuga('u');
			LineRed();
			move_enc(200, v, 'b');
		}
		else
		{
			para=para+1;
			if(para%2==0)
			{
				hapuga('u');
				move_enc(200, v, 'b');
			}
			else
			{
				hapuga('d');
				move_enc(200, v, 'b');
			}
		}
		povleft();
		while(SensorValue[S2]>15||SensorValue[S3]>15)
		{
			Line();
		}
		stopmotor();
		povleft();
	}
	if(dom==2)
	{
		if(ind3==col&&ind4==col)
		{
			para=para+2;
			hapuga('d');
			move_enc(200, v, 'b');
			hapuga('u');
			LineRed();
			move_enc(200, v, 'b');
		}
		else
		{
			para=para+1;
			if(para%2==0)
			{
				hapuga('u');
				move_enc(200, v, 'b');
			}
			else
			{
				hapuga('d');
				move_enc(200, v, 'b');
			}
		}
		povleft();
		while(SensorValue[S2]>15||SensorValue[S3]>15)
		{
			Line();
		}
		stopmotor();
		povright();
	}
	if(dom==1)
	{
		if(ind1==col&&ind2==col)
		{
			para=para+2;
			hapuga('d');
			move_enc(200, v, 'b');
			hapuga('u');
			LineRed();
			move_enc(200, v, 'b');
		}
		else
		{
			para=para+1;
			if(para%2==0)
			{
				hapuga('u');
				move_enc(200, v, 'b');
			}
			else
			{
				hapuga('d');
				move_enc(200, v, 'b');
			}
		}
		povleft();
		while(SensorValue[S2]>15||SensorValue[S3]>15)
		{
			Line();
		}
		stopmotor();
		povright();
	}
}

void stapt()
{
	motor[motorD]=-25;
	move_enc(200, v, 'f');
	Line1Cross();
}

void info(short dom)
{
	tHTCS2 colorSensor;
	initSensor(&colorSensor, S4);
	goColor();
	if(colorSensor.color==2||colorSensor.color==3)
	{
		blue=blue+1;
	}
	if(colorSensor.color==4)
	{
		green=green+1;
	}
	if(colorSensor.color==6)
	{
		yellow=yellow+1;
	}
	if(dom==1)
	{
		if(colorSensor.color==3)
		{
			ind1=2;
		}
		else
		{
			ind1=colorSensor.color;
		}
	}
	if(dom==2)
	{
		if(colorSensor.color==3)
		{
			ind1=2;
		}
		else
		{
			ind3=colorSensor.color;
		}
	}
	if(dom==3)
	{
		if(colorSensor.color==3)
		{
			ind1=2;
		}
		else
		{
			ind5=colorSensor.color;
		}
	}
	while(colorSensor.color>0)
	{
		readSensor(&colorSensor);
		motor[motorB]=40;
		motor[motorC]=-40;
	}
	stopmotor();
	nMotorEncoder[motorB]=0;
	while(colorSensor.color!=2&&colorSensor.color!=3&&colorSensor.color!=4&&colorSensor.color!=6)
	{
		readSensor(&colorSensor);
		motor[motorB]=25;
		motor[motorC]=-25;
		if(SensorValue[S2]<15&&SensorValue[S3]<15)
		{
			break;
		}
	}
	if(dom==1)
	{
		if(colorSensor.color==3)
		{
			ind1=2;
		}
		else
		{
			ind2=colorSensor.color;
		}
	}
	if(dom==2)
	{
		if(colorSensor.color==3)
		{
			ind1=2;
		}
		else
		{
			ind4=colorSensor.color;
		}
	}
	if(dom==3)
	{
		if(colorSensor.color==3)
		{
			ind1=2;
		}
		else
		{
			ind6=colorSensor.color;
		}
	}
}

void CheckDom1()
{
	motor[motorD]=-25;
	move_enc(250, v, 'f');
	move_enc(260, 50, 'l');
	motor[motorD]=0;
	motor[motorB]=-40;
	motor[motorC]=40;
	wait10Msec(100);
	stopmotor();
	info(1);
	motor[motorD]=25;
	v=25;
	goBlack(1);
	wait10Msec(20);
	povleft();
	motor[motorD]=0;
	LineCross();
	povright();
	Line_enc(300);
	povright();
}

void excess()
{
	nMotorEncoder[motorB]=0;
	tHTCS2 colorSensor;
	initSensor(&colorSensor, S4);
	readSensor(&colorSensor);
	t=4;
	while(colorSensor.color==0)
	{
		readSensor(&colorSensor);
		Line();
		if(nMotorEncoder[motorB]>400)
		{
			t=3;
			break;
		}
	}
	stopmotor();
	if(t==4)
	{
		mot1_enc(200, 'b', 'f');
		mot1_enc(180, 'c', 'f');
		move_enc(100, v, 'b');
		Line1Cross();
		Line_enc(20);
		mot1_enc(550, 'b', 'b');
		move_enc(420, 30, 'f');
		hapuga('d');
		move_enc(500, 40, 'l');
		move_enc(130, 20, 'b');
		zahvat('c');
		v=50;
		move_enc(250, v, 'l');
		goBlack(1);
		move_enc(50, v, 'f');
		goBlack(1);
		povleft();
	}
	else
	{
		move_enc(250, v, 'b');
		povleft();
		LineCross();
		v=25;
		Line_enc(30);
		mot1_enc(500, 'b', 'f');
		nMotorEncoder[motorB]=0;
		readSensor(&colorSensor);
		while(colorSensor.color==0)
		{
			readSensor(&colorSensor);
			motor[motorB]=30;
			motor[motorC]=-30;
			if(nMotorEncoder[motorB]>400)
			{
				t=2;
				break;
			}
		}
		stopmotor();
		if(t==3)
		{
			move_enc(20, v, 'f');
			move_enc(270, 40, 'r');
			move_enc(180, 30, 'f');
			hapuga('d');
			move_enc(500, 40, 'l');
			move_enc(130, 20, 'b');
			zahvat('c');
			move_enc(500, v, 'l');
			goBlack(3);
			povleft();
		}
		if(t==2)
		{
			while(SensorValue[S1]>15)
			{
				moving(v, 'b');
			}
			povright();
			LineCross();
			//while(SensorValue[S2]>20)
			//{
			//	motor[motorB]=-v;
			//}
			//while(SensorValue[S2]<50)
			//{
			//	motor[motorB]=-v;
			//}
			//while(SensorValue[S2]>17)
			//{
			//	motor[motorB]=-v;
			//}
			//while(SensorValue[S2]<50)
			//{
			//	motor[motorB]=-v;
			//}
			//stopmotor();
			//wait10Msec(10);
			//while(SensorValue[S3]>20)
			//{
			//	motor[motorC]=-v;
			//}
			//stopmotor();
			mot1_enc(500, 'b', 'b');
			move_enc(250, 25, 'b');
			zahvat('c');
			move_enc(500, v, 'l');
			move_enc(240, 25, 'f');
			wait1Msec(50);
			hapuga('d');
			move_enc(250, v, 'l');
			goBlack(1);
			povright();
		}
	}
}

void CheckDom2()
{
	//v=40;
	LineRed();
	stopmotor();
	move_enc(110, v, 'b');
	move_enc(250, 30, 'l');
	move_enc(450, v, 'b');
	info(2);
	goBlack(3);
	povleft();
}

void akkum()
{
	v=25;
	Line_enc(200);
	//v=50;
	while(SensorValue[S2]>15||SensorValue[S3]>15)
	{
		Line();
	}
	stopmotor();
	move_enc(500, 30, 'l');
	move_enc(115, 35, 'b');
	motor[motorD]=70;
	wait10Msec(95);
	motor[motorD]=0;
	goBlack(2);
	wait10Msec(500);
	//move_enc(20, v, 'f');
	povright();
	eraseDisplay();
	displayCenteredBigTextLine(2, "%d", SensorValue[S1]);
	stopmotor();
	wait10Msec(500);
}

void CheckDom3()
{
	perebros();
	LineCross();
	wait10Msec(40);
	povright();
	LineRed();
	stopmotor();
	move_enc(110, v, 'b');
	move_enc(250, 30, 'l');
	move_enc(450, v, 'b');
	info(3);
	goBlack(2);
}

void putblue()
{
	while (SensorValue[S1]<60)
	{
		motor[motorB]=v;
		motor[motorC]=-v;
	}
	while (SensorValue[S1]>40)
	{
		motor[motorB]=v;
		motor[motorC]=-v;
	}
	stopmotor();
	while (SensorValue[S1]<60)
	{
		motor[motorB]=v;
	}
	while (SensorValue[S1]>40)
	{
		motor[motorB]=v;
	}
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB]<350)
	{
		Line2();
	}
	while(SensorValue[S3]<65)
	{
		Line2();
	}
	while(SensorValue[S3]<20)
	{
		Line2();
	}
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB]<270)
	{
		Line2();
	}
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB]>-230)
	{
		motor[motorB]=-v;
		motor[motorC]=-v;
	}
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB]>-230)
	{
		motor[motorB]=-v;
		motor[motorC]=v;
	}
	stopmotor();
	motor[motorA]=-100;
	wait10Msec(30);
	motor[motorA]=0;
	while(SensorValue[S1]<65)
	{
		motor[motorB]=v;
		motor[motorC]=-v;
	}
	while(SensorValue[S1]>20)
	{
		motor[motorB]=v;
		motor[motorC]=-v;
	}
	wait1Msec(10);
	stopmotor();
	motor[motorA]=20;
	wait10Msec(50);
	motor[motorA]=0;
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB]>-500)
	{
		motor[motorB]=-v;
	}
	stopmotor();
	motor[motorA]=-20;
	wait10Msec(50);
	motor[motorA]=0;
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB]>-150)
	{
		motor[motorB]=-v;
		motor[motorC]=v;
	}
	stopmotor();
	motor[motorA]=20;
	wait10Msec(50);
	motor[motorA]=0;
	while(SensorValue[S3]<65)
	{
		motor[motorB]=v;
		motor[motorC]=-v;
	}
	motor[motorA]=-20;
	while(SensorValue[S3]>30)
	{
		motor[motorB]=v;
		motor[motorC]=-v;
	}
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB]<230)
	{
		motor[motorB]=v;
		motor[motorC]=-v;
	}
	motor[motorA]=0;
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB]<230)
	{
		motor[motorB]=v;
		motor[motorC]=v;
	}
	while(SensorValue[S1]<65)
	{
		motor[motorB]=v;
		motor[motorC]=-v;
	}
	while(SensorValue[S1]>20)
	{
		motor[motorB]=v;
		motor[motorC]=-v;
	}
	wait1Msec(30);
	stopmotor();
	motor[motorA]=20;
	wait10Msec(35);
	motor[motorA]=0;
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB]>-500)
	{
		motor[motorB]=-v;
	}
	stopmotor();
}

task main()
{
	v=25; k1=0.2; k2=10;ind5=2;
	//stapt();
	//CheckDom1();
	//excess();
	//CheckDom2();
	//akkum();
	//CheckDom3();
	//putblue();
	if (ind5==2||ind5==3||ind6==2||ind6==3)
	{
		while (SensorValue[S1]<60)
		{
			motor[motorB]=v;
			motor[motorC]=-v;
		}
		while (SensorValue[S1]>20)
		{
			motor[motorB]=v;
			motor[motorC]=-v;
		}
		LineRed();
	}
}
